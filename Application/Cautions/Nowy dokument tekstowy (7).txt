CUBEMX 6.1.0   dzial dla SD f_mount  wyzsza wersja nie dziala !!!
RTC_INIT() na samym koncu wszystkich inicjaliacji umiescic bo inczaej zawiesza sie
f_sync(fp);	
kolejnosc funkcji init w main tak ajk ustawia cube !!!	i musi byc RCC global interrupt			/* Flush cached data */



ciekawy powerfail!!
ADUM130 ADUM140  opto
AD421  loop power 4-20mA

#define BLUE_LED_TOGGLE   	ShiftReg_WriteVal(SHIFT_REG_DATA^=(1 << 7))  //exor ^ na toogle

  taskENTER_CRITICAL();
  fr = f_open(&fsrc, "test.txt", FA_OPEN_EXISTING | FA_READ);
  if (fr == FR_OK)
  {
  	HAL_Delay(1);
  }
  taskEXIT_CRITICAL();

if..
else
  continue;

if (0x01 & xEventGroupGetBits(xBoardResetEvent))


f_gets(ParametersReadWriteBuffer, BUFFER_SIZE, &ParametersFile);
				f_open(&FilEvent, archEventFilePath, FA_OPEN_EXISTING | FA_WRITE);
				f_lseek(&FilEvent, f_size(&FilEvent));
				f_printf(&FilEvent, archBufferEvent);
				f_close(&FilEvent);

screenSaver.c
void StartScreenSaverTimer(void
void vScreenSaverCallback(TimerHandle_t pxTimer)

void sendEvent(char* eventDesc)
{
	char* eventMessage = pvPortMalloc(100);
	if (NULL == eventMessage)
	{

	}
	else
	{
		strncpy(eventMessage,eventDesc,100);
		if(pdPASS != xQueueSend(xMessageQueue, &eventMessage, 20))
			vPortFree(eventMessage);
	}
}

event group lokalne w watku a nie w main.c globalne

void ResetLogOutTimer(void)
{
	xTimerReset(xLogOutTimer, LOG_OUT_TIME);
}
void vLogOutTimerCallback(TimerHandle_t pxTimer)
{
	UserLogOut();
	xTimerStop(pxTimer, 0);
}

xQueueHandle xDataQueue, xDataResolution, xDataStatusQueue;
xQueueHandle xTotalizerQueue, xTotalizerResolution;
xQueueHandle xChannelsQueue, xMessageQueue;

xTaskHandle vtaskArchiveHandle;
EventGroupHandle_t xArchiveEventGroup;
SemaphoreHandle_t xSwitchSemaphore;

SemaphoreHandle_t xArchiveWrite;

void vtaskArchive(void *pvParameters)
{
	vTaskDelay(500);
	uint8_t ChannelsNumber={0};

	xSwitchSemaphore = xSemaphoreCreateMutex();
	xArchiveWrite = xSemaphoreCreateMutex();

	xArchiveEventGroup = xEventGroupCreate();

	xMessageQueue = xQueueCreate(20, sizeof(char *));

	xDataQueue = xQueueCreate(100, sizeof(float));
	xDataStatusQueue = xQueueCreate(100, sizeof(uint8_t));
	xDataResolution = xQueueCreate(100, sizeof(char));

	xTotalizerQueue = xQueueCreate(200, sizeof(uint64_t));
	xTotalizerResolution = xQueueCreate(200, sizeof(char));

	archPollingState = FRAM_Read(ARCHIVE_STATE_ADDR);
	if (archPollingState != 0 && archPollingState != 1)
		archPollingState = 0;

	memset(archBufferArchive, 0, sizeof(archBufferArchive));
	memset(archBufferTotalizer, 0, sizeof(archBufferTotalizer));

	while (1)
	{
		if (STARTUP_WaitForBits(0x0010))
		{
			STARTUP_ClaerBits(0x0010);
			STARTUP_SetBits(0x0020);

			xQueueReceive(xChannelsQueue, &ChannelsNumber, 0);

			if (FRAM_Read(NEW_ARCHIVE_FLAG_ADDR) == 1)
			{
				archCreateNewArchive();
				FRAM_Write(NEW_ARCHIVE_FLAG_ADDR, 0);
			}

			archStartArchive();

			sendEvent("SYS:STOP");
			sendEvent("SYS:START");

			if (ChannelsNumber != 0)
			{
				while (1)
				{
					if (xEventGroupWaitBits(xArchiveEventGroup, 0x01 | 0x02, pdTRUE, pdFALSE, 0) != 0)
					{
						xQueueReset(xDataQueue);
						xQueueReset(xDataStatusQueue);
						xQueueReset(xDataResolution);
						xQueueReset(xTotalizerQueue);
						archCreateNewArchive();
					}

					if ( xSemaphoreTake( xSwitchSemaphore, ( TickType_t ) 0 ) == pdTRUE)
					{
						if (archPollingState != 0)
						{
							updateArchiveTimeAndDate();
							archDataPolling();
							archTotalizerPolling();
						}
						xSemaphoreGive(xSwitchSemaphore);
					}

					archEventPolling();
					WDFlags[5] = ALIVE;
					vTaskDelay(250);
				}
			}
			else
			{
				while (1)
				{
					archEventPolling();
					WDFlags[5] = ALIVE;
					vTaskDelay(250);
				}
			}
		}
		else
			continue;
	}
}
configSUPPORT_DYNAMIC_ALLOCATION  w FreeRtos.h


//---------------------------------------------------------------------------------

SemaphoreHandle_t xSwitchSemaphore;
xSwitchSemaphore = xSemaphoreCreateMutex();

if ( xSemaphoreTake( xSwitchSemaphore, ( TickType_t ) 0 ) == pdTRUE)
{
   .....
   xSemaphoreGive(xSwitchSemaphore);
}

//---------------------------------------------------------------------------------


EventGroupHandle_t xArchiveEventGroup;
xArchiveEventGroup = xEventGroupCreate();

if (xEventGroupWaitBits(xArchiveEventGroup, 0x01 | 0x02, pdTRUE, pdFALSE, 0) != 0)
{
  .....
}

EventGroupHandle_t taskSequence;

void STARTUP_Init(void)
{
	taskSequence = xEventGroupCreate();
	xEventGroupSetBits(taskSequence, 0x0000);
}

uint32_t STARTUP_WaitForBits(uint32_t bits)
{
	if ((xEventGroupWaitBits(taskSequence, bits,pdFALSE, pdFALSE, 100) & bits) == bits)
		return 1;
	else
		return 0;
}


void STARTUP_SetBits(uint32_t bits)
{
	xEventGroupSetBits(taskSequence, bits);
}

void STARTUP_ClaerBits(uint32_t bits)
{
	xEventGroupClearBits(taskSequence, bits);
}



//---------------------------------------------------------------------------------


xQueueHandle xDataQueue;
xDataQueue = xQueueCreate(100, sizeof(float));
xQueueReset(xDataQueue);
xQueueSend(xDataQueue, (void * ) &Channels[channelNumber].value, 0);
while (uxQueueMessagesWaiting(xDataQueue) > 0)
{
	xQueueReceive(xDataQueue, &archDataVal[queueDataSize], 0);
	queueDataSize++;
}

//---------------------------------------------------------------------------------

portTickType xLastExecutionTime;
xLastExecutionTime = xTaskGetTickCount();
vTaskDelayUntil(&xLastExecutionTime, 100);

//--------------------------------------------------------------------------------------

xTaskHandle vtaskBSPHandle;
xTaskCreate(vtaskBSP, "vtaskBSP", 3000, NULL, ( unsigned portBASE_TYPE )2, &vtaskBSPHandle);
osKernelStart();

void vtaskBSP(void *pvParameters)
{
	while (1)
	{
		if (STARTUP_WaitForBits(0x0001))
		{
			STARTUP_ClaerBits(0x0001);
			STARTUP_SetBits(0x0002);

			while (1)
			{
				BSP_Background();
				GUI_Exec();
				vTaskDelay(2);
			}
		}
		else
			continue;
	}
}

void vtaskEth(void *pvParameters)
{
	/* Initilaize the LwIP stack */

	while (1)
	{
		if (STARTUP_WaitForBits(0x0040))
		{
			STARTUP_ClaerBits(0x0040);

			tcpip_init(NULL, NULL);

			Netif_Config();
			http_server_netconn_init();
			modbus_init();

			MBTCP_Initialize();

			DNS_Init();
			EMAIL_Init();

			STARTUP_SetBits(0x0080);

			vTaskDelete(NULL);
		}
		else
			continue;
	}
}


1.▶
2. SDRAM period CLOCK z 3 na 2  
3. priorytety przerwan DMA muszą byc inne a nie 5 I KAZDY mUSI BYC INNYY !!!
4. callback eth rozlaczenie i wlaczenie kabla  net_config() w zakladdcd set callback
5. powerfail
6. RTC DST
7. usiawienia PHY addres USER fi w cube
8. screenSaver.xTimer = xTimerCreate("ScreenSaverTimer", screenSaver.time, 0, ( void * )0,  vScreenSaverCallback);  screenSaver.c
9.f_gets
10.  char key[] = "1234567890.";  strspn(strIP, key);
11. strcpy(version, strtok_r(NULL, ",", &readpointer));
    int major = atoi(strtok_r(version, ".", &readpointer));
12. extern EXPANSION_CARD ExpansionCards[];  bez indeksu [..]
13.	f_open(&graphicFile, pathToFile, FA_READ);
	f_stat(pathToFile,&fno);
	f_read(&graphicFile, buff, fno.fsize, &bytesReadFromFile); 
14. f_putc zamiast f_write
15. mini_vsnprintf(char *buffer, unsigned int buffer_len, const char *fmt, va_list va)
{
	char *pbuffer = buffer;
	char bf[24];
	char ch;

	int _putc(char ch)
	{
		if ((unsigned int)((pbuffer - buffer) + 1) >= buffer_len)
			return 0;
		*(pbuffer++) = ch;
		*(pbuffer) = '\0';
		return 1;
	}

	int _puts(char *s, unsigned int len)
	{
		unsigned int i;

		if (buffer_len - (pbuffer - buffer) - 1 < len)
			len = buffer_len - (pbuffer - buffer) - 1;

		/* Copy to buffer */
		for (i = 0; i < len; i++)
			*(pbuffer++) = s[i];
		*(pbuffer) = '\0';

		return len;
	}

	while ((ch=*(fmt++))) {
		if ((unsigned int)((pbuffer - buffer) + 1) >= buffer_len)
			break;
	.......
}

16.   	if (ERR_OK == netconn_recv(conn, &inbuf))
	{
		if (netconn_err(conn) == ERR_OK)
		{
			buflen = netbuf_len(inbuf);
			buf = pvPortMalloc(buflen*sizeof(char));
			netbuf_copy(inbuf, buf, buflen);
			if ((strncmp(buf, "GET /LOGIN", 10) == 0) )
			{
				char* ret;
				char* givenPassword;
				char* realPassword;
				ret = strstr(buf,"x-usr-psw");

17.   				f_open(&FilEvent, archEventFilePath, FA_OPEN_EXISTING | FA_WRITE);
				f_lseek(&FilEvent, f_size(&FilEvent));
				f_printf(&FilEvent, archBufferEvent);
				f_close(&FilEvent);

18. w DWORD get_fattime(void)  ustawic RTC zapisu pliku
19.  
lowipopts.h
#define TCP_SND_QUEUELEN 16
#define DEFAULT_THREAD_STACKSIZE 8000
*----- Value in opt.h for DEFAULT_UDP_RECVMBOX_SIZE: 0 -----*/
#define DEFAULT_UDP_RECVMBOX_SIZE 128
/*----- Value in opt.h for DEFAULT_TCP_RECVMBOX_SIZE: 0 -----*/
#define DEFAULT_TCP_RECVMBOX_SIZE 128
/*----- Value in opt.h for DEFAULT_ACCEPTMBOX_SIZE: 0 -----*/
#define DEFAULT_ACCEPTMBOX_SIZE 128
#define TCPIP_MBOX_SIZE 128
#define TCPIP_THREAD_STACKSIZE 16000

opt.h
#define TCP_MSS                         1460
#define PBUF_POOL_SIZE                  24
#define MEMP_NUM_NETCONN                32
#define MEMP_NUM_NETBUF                 32
#define MEMP_NUM_TCP_SEG                32
#define MEMP_NUM_TCP_PCB                32
#define MEMP_NUM_PBUF                   32

20. w cubeMX opisywać GPIO własne nazwy
21.  Dst->LowSignalValue = atof(strtok_r(NULL, ",", &readpointer));
22.  strspn(strIP, key);
23. register int liczba; zmienna w rejestrze i szybki dostep
24. if( xTaskGetCurrentTaskHandle() == xIdleHandle )  w EndIdleMonitor();
25. pvMBFrameCloseCur = MB_PORT_HAS_CLOSE ? vMBPortClose : NULL;
26. w  funkcji:  char* dest;   result = dest = malloc(in_len / 4 * 3 + 1);   return result;
27. w pliku .h  dac #include <stdint.h> aby rozumial typy np uint8_t
28.  void
vMBPortClose( void )
{
    extern void vMBPortSerialClose( void );
    extern void vMBPortTimersDisable( void );
    vMBPortSerialClose(  );
    vMBPortTimersDisable(  );
}
29. if (TakeArchiveSemaphore(50))
					{
						f_open(&arch_file, filepath, FA_READ);
						f_lseek(&arch_file, filePointer);
30. dla HTTP:
if(ERR_OK == netconn_recv(conn, &inbuf)),  
buflen = netbuf_len(inbuf);
buf = pvPortMalloc(buflen*sizeof(char));
netbuf_copy(inbuf, buf, buflen);
else if ((strncmp(buf, "GET /archive/", 13) == 0))
	vPortFree(buf);
31.
if (TakeArchiveSemaphore(50))
{
						f_open(&arch_file, filepath, FA_READ);
						f_lseek(&arch_file, filePointer);
						res = f_read(&arch_file, archDownBuffer, DOWNLOAD_BUFFER_SIZE, &archDownCounter);
						filePointer = arch_file.fptr;
						f_close(&arch_file);

	
					GiveArchiveSemaphore();
}
32. ethernetif_notify_conn_changed() tą funkcje uzupelnij aby po wyl zasilania i kabla eth i po wlaczeniu zasilania i pozniej wlozeniu kabla eth strona www dzialala
33. ciekawa inicjaliza strultur do stanow pierwotnych
typedef volatile struct {
	unsigned short noSettings:1;
	unsigned short firstTimeSettingsLauncher:1;
	unsigned short receivedNewStates:1;
	unsigned short watchdog:1;

} MAINFLAGS_StructTypeDef;

volatile MAINFLAGS_StructTypeDef GeneralFlag =
{
		TRUE, 	//noSettings
		TRUE, 	//firstTimeSettingsLauncher
		FALSE,	//receivedNewStates
		FALSE		//watchdog
};

34. fajny zapis:
*/
typedef struct { I16P x,y; } GUI_POINT;
typedef struct { I16 x0,y0,x1,y1; } LCD_RECT;
35.   if (conn->state == NETCONN_NONE){   }
36. ALIGN_32BYTES();
37. ceil() zaokroglenie w gore
    floor() zaokr. w dół
38.
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {

	if (huart->Instance == USART6)
		SetNewTimeAndDate();
	if (huart->Instance == USART1)
		FREQUENCY_SetNewDataEvent();
}
void FREQUENCY_SetNewDataEvent(void)
{
	BaseType_t xHigherPriorityTaskWoken = pdFALSE, xResult = pdFAIL;
	xResult = xEventGroupSetBitsFromISR(xDiscreteInputEvent, FREQUENCY_NEW_DATA, &xHigherPriorityTaskWoken);
	if (xResult == pdPASS)
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
39.   = NAN;
40.
 if(isnan(*rawValue))
	break;
41.
if (xEventGroupWaitBits(xAnalogInputEvent, 0x3, pdTRUE, pdFALSE, 10)) jezeli ktoryklolwiek bit z 0x03 sie zmieni to wchodzi w if i po wyjsciu kasuje ten bit
void EnableCalibrationMode(void)
{
	xEventGroupSetBits(xAnalogInputEvent, 2);
}

void DisableCalibrationMode(void)
{
	xEventGroupSetBits(xAnalogInputEvent, 1);
}
42. 	
HAL_TIM_Base_Stop_IT(&htim4);  jesli to to musi byc to ponizej tez!!! bo inacej zacina sie
HAL_TIM_Base_MspDeInit(&htim4);

43.   osMessagePut ( ConnectionEvent, CARD_CONNECTED, osWaitForever);
    event = osMessageGet( ConnectionEvent, osWaitForever );
    
    if( event.status == osEventMessage )
    {
      switch(event.value.v)
      {

44. strcat(RS485Buffer, "Zegar ustawiony");























































































































//	void _ServiceRGB(void)
//	{
//		const char *txtKey[]								= {"R+",	  "G+", 	  "B+",		 "R-", 	    "G-",	  "B-"};
//		const COLORS_DEFINITION colorTxtKey[]		= {RED,	  GREEN, 	BLUE,		 RED, 	    GREEN,	 BLUE};
//		const COLORS_DEFINITION colorTxtPressKey[]= {DARKRED,DARKRED, LIGHTGREEN,LIGHTGREEN, DARKBLUE,DARKBLUE};
//		const uint16_t dimKeys[] = {3,2};
//
//
//		KEYBOARD_SetDimKey(k, shape, widthKey, heightKey, txtKey[0]);
//
//		int head = KEYBOARD_GetHead(k);
//
//
//		XY_Touch_Struct posKey[ dimKeys[0]*dimKeys[1] ];
//
//
//		KEYBOARD_SetPosKey(k,posKey,dimKeys,head);
//
//
//		KEYBOARD_SetDimAll(k,dimKeys,head);
//
//
//		switch((int)selBlockPress)
//		{
//			case KEY_All_release:
//				KEYBOARD_KeysAllRelease(k,posKey,txtKey,colorTxtKey,dimKeys,SL(LANG_nazwa_8),v.FONT_COLOR_Descr);
//				break;
//
//			case KEY_Red_plus:	 _KeyStrPressDisp_oneBlock(k,posKey[0], txtKey[0], colorTxtPressKey[0]);	break;	/* Wykorzystac to dla przesuwu dotyku i pozostawienie sladu :) */
//			case KEY_Green_plus:	 _KeyStrPressDisp_oneBlock(k,posKey[1], txtKey[1], colorTxtPressKey[1]);	break;
//			case KEY_Blue_plus:	 _KeyStrPressDisp_oneBlock(k,posKey[2], txtKey[2], colorTxtPressKey[2]);	break;
//			case KEY_Red_minus: 	 _KeyStrPressDisp_oneBlock(k,posKey[3], txtKey[3], colorTxtPressKey[3]);	break;
//			case KEY_Green_minus: _KeyStrPressDisp_oneBlock(k,posKey[4], txtKey[4], colorTxtPressKey[4]);	break;
//			case KEY_Blue_minus:  _KeyStrPressDisp_oneBlock(k,posKey[5], txtKey[5], colorTxtPressKey[5]);	break;
//		}
//
//
//		KEYBOARD_SetTouch(k,startTouchIdx,dimKeys,posKey);
//
//	}

//	void _ServiceCoeff(void)
//	{
//		const char *txtKey[]								= {"+",	  "-"};
//		const COLORS_DEFINITION colorTxtKey[]		= {WHITE,  WHITE};
//		const COLORS_DEFINITION colorTxtPressKey[]= {DARKRED,DARKRED};
//		const uint16_t dimKeys[] = {2,1};
//
//		if(shape!=0){
//			if(KeysAutoSize == widthKey){
//				s[k].widthKey =  heightKey + LCD_GetWholeStrPxlWidth(fontID,(char*)txtKey[0],0,NoConstWidth) + heightKey;		/*	space + text + space */
//				s[k].heightKey = heightKey + LCD_GetFontHeight(fontID) + heightKey;
//			}
//		}
//		int head = s[k].interSpace + LCD_GetFontHeight(fontID_descr)/* + s[k].interSpace*/;
//
//		XY_Touch_Struct posHead={0,0};
//		XY_Touch_Struct posKey[]=
//		  {{1*s[k].interSpace + 0*s[k].widthKey,	s[k].interSpace + head},
//			{2*s[k].interSpace + 1*s[k].widthKey, 	s[k].interSpace + head}};
//
//		int countKey = dimKeys[0]*dimKeys[1]; 		/* = STRUCT_TAB_SIZE(txtKey); */
//
//		widthAll =  dimKeys[0]*s[k].widthKey  + (dimKeys[0]+1)*s[k].interSpace;
//		heightAll = dimKeys[1]*s[k].heightKey + (dimKeys[1]+1)*s[k].interSpace + head;
//
//		switch((int)selBlockPress)
//		{
//			case KEY_All_release:
//				LCD_ShapeWindow( s[k].shape,0,widthAll,heightAll, 0,0, widthAll,heightAll, SetBold2Color(frameColor,s[k].bold), bkColor,bkColor );
//				_StrDescr(k,posHead, SL(LANG_CoeffKeyName), v.FONT_COLOR_Descr);
//
//				fillColor = BrightIncr(fillColor,0xE);
//				for(int i=0; i<countKey; ++i){
//					i<countKey-1 ? _KeyStr(k,posKey[i],txtKey[i],colorTxtKey[i]) : _KeyStrDisp(k,posKey[i],txtKey[i],colorTxtKey[i]);
//				}
//				break;
//
//			case KEY_Coeff_plus:	  _KeyStrPressDisp_oneBlock(k,posKey[0], txtKey[0], colorTxtPressKey[0]);	break;
//			case KEY_Coeff_minus:  _KeyStrPressDisp_oneBlock(k,posKey[1], txtKey[1], colorTxtPressKey[1]);	break;
//		}
//
//		if(startTouchIdx){
//			for(int i=0; i<countKey; ++i)
//				_SetTouch(k,ID_TOUCH_GET_ANY_POINT_WITH_WAIT, s[k].startTouchIdx + i, TOUCH_GET_PER_X_PROBE, posKey[i]);
//		}
//	}
//
//	int _ServiceLenOffsWin(FUNC_MAIN *pfunc,FUNC_MAIN_INIT)
//	{
//		#define _NMB2KEY	8
//		const char *txtKey[]								= {"(.......)", "(...)", "(.......)",	"(.......)", " _ ", " _ ", "|  |", "||", "Info spaces", "Write spaces", "Reset spaces"};
//		const COLORS_DEFINITION colorTxtKey[]		= {WHITE,  WHITE,  WHITE,  WHITE,  WHITE,  WHITE,  WHITE,	 WHITE,		WHITE,		 WHITE,			  WHITE};
//		const COLORS_DEFINITION colorTxtPressKey[]= {DARKRED,DARKRED,DARKRED,DARKRED,DARKRED,DARKRED,DARKRED,  DARKRED,	DARKRED, 	 DARKRED,		  DARKRED};
//		const uint16_t dimKeys[] = {4,3};
//
//		int widthKeyCorrect = 0;
//		int heightKeyCorrect = 5;
//		if(shape!=0){
//			if(KeysAutoSize == widthKey){
//				s[k].widthKey  = heightKey + LCD_GetWholeStrPxlWidth(fontID,(char*)txtKey[ 			 STRING_GetTheLongestTxt(_NMB2KEY-1,(char**)txtKey) 				],0,NoConstWidth) + heightKey -widthKeyCorrect;		/*	space + text + space */
//				s[k].widthKey2 = heightKey + LCD_GetWholeStrPxlWidth(fontID,(char*)txtKey[_NMB2KEY + STRING_GetTheLongestTxt(2,			(char**)(txtKey+_NMB2KEY)) ],0,NoConstWidth) + heightKey -widthKeyCorrect;
//				s[k].heightKey = heightKey +heightKeyCorrect + LCD_GetFontHeight(fontID) + heightKey +heightKeyCorrect;
//
//				int diff;
//				if		 (0 < (diff = dimKeys[0]*(s[k].widthKey+s[k].interSpace) - dimKeys[1]*(s[k].widthKey2+s[k].interSpace)))		s[k].widthKey2 += diff 		 / dimKeys[1];
//				else if( 0 > diff)																																s[k].widthKey  += ABS(diff) / dimKeys[0];
//		}}
//
//		int countKey = dimKeys[0]*dimKeys[1] - 1;
//		int head = s[k].interSpace + 2*LCD_GetFontHeight(fontID_descr) + s[k].interSpace;
//		int edgeSpace = s[k].interSpace + s[k].interSpace/2;
//
//		int widthShape1 =  s[k].widthKey - s[k].widthKey/4;
//		int heightShape1 = LCD_GetFontHeight(fontID) + LCD_GetFontHeight(fontID)/3;  /* s[k].heightKey - s[k].heightKey/3; */
//
//		XY_Touch_Struct posHead={0, s[k].interSpace};
//		XY_Touch_Struct posKey[]=
//		  {{edgeSpace		 					 + 0*s[k].widthKey,	1*s[k].interSpace + 0*s[k].heightKey + head},
//			{edgeSpace + 1*s[k].interSpace + 1*s[k].widthKey, 	1*s[k].interSpace + 0*s[k].heightKey + head},
//			{edgeSpace + 2*s[k].interSpace + 2*s[k].widthKey, 	1*s[k].interSpace + 0*s[k].heightKey + head},
//			{edgeSpace + 3*s[k].interSpace + 3*s[k].widthKey, 	1*s[k].interSpace + 0*s[k].heightKey + head},
//			\
//			{edgeSpace		 					 + 0*s[k].widthKey,	2*s[k].interSpace + 1*s[k].heightKey + head},
//			{edgeSpace + 1*s[k].interSpace + 1*s[k].widthKey, 	2*s[k].interSpace + 1*s[k].heightKey + head},
//			{edgeSpace + 2*s[k].interSpace + 2*s[k].widthKey, 	2*s[k].interSpace + 1*s[k].heightKey + head},
//			{edgeSpace + 3*s[k].interSpace + 3*s[k].widthKey, 	2*s[k].interSpace + 1*s[k].heightKey + head},
//			\
//			{edgeSpace		 					 + 0*s[k].widthKey2,	3*s[k].interSpace + 2*s[k].heightKey + head + s[k].interSpace-s[k].interSpace/3},
//			{edgeSpace + 1*s[k].interSpace + 1*s[k].widthKey2, 3*s[k].interSpace + 2*s[k].heightKey + head + s[k].interSpace-s[k].interSpace/3},
//			{edgeSpace + 2*s[k].interSpace + 2*s[k].widthKey2, 3*s[k].interSpace + 2*s[k].heightKey + head + s[k].interSpace-s[k].interSpace/3}};
//
//		widthAll 	=   dimKeys[0]	  *s[k].widthKey   + (dimKeys[0]+1-2)*s[k].interSpace + 2*edgeSpace;
//		widthAll_c 	=  (dimKeys[0]-1)*s[k].widthKey2  + (dimKeys[0]+0-2)*s[k].interSpace + 2*edgeSpace;
//		if(widthAll_c > widthAll)	widthAll = widthAll_c;
//		heightAll = head + dimKeys[1]*s[k].heightKey + (dimKeys[1]+1-1)*s[k].interSpace + s[k].interSpace-s[k].interSpace/3 + edgeSpace;
//
//		void 	_SetFlagWin	 (void){	SET_bit(s[k].param,7); }
//		int 	_IsFlagWin	 (void){ return CHECK_bit(s[k].param,7); }
//		void 	_RstFlagWin	 (void){	RST_bit(s[k].param,7); }
//
//		POS_SIZE win = { .pos={ s[k].x+widthAll+15, s[k].y 				 }, .size={200,250} };
//		POS_SIZE win2 ={ .pos={ 15, 					  s[k].y+heightAll+15 }, .size={600, 60} };
//
//		LCD_DisplayRemeberedSpacesBetweenFonts(1,pCHAR_PLCD(0),(int*)(&win.size.w));
//		win.size.w *= LCD_GetWholeStrPxlWidth(fontID_descr,(char*)"r",0,NoConstWidth);
//
//		void _WinInfo(char* txt){
//			BKCOPY_VAL(fillColor_c[0],fillColor,BrightIncr(fillColor,0x1A));
//			LCD_ShapeWindow( s[k].shape, 0, win2.size.w, win2.size.h, 0,0, win2.size.w, win2.size.h, SetBold2Color(frameColor,s[k].bold), fillColor,bkColor );
//			LCD_Xmiddle(MIDDLE_NR,SetPos,SetPosAndWidth(0,win2.size.w),NULL,0,NoConstWidth);
//			LCD_Ymiddle(MIDDLE_NR,SetPos,SetPosAndWidth(0,win2.size.h));
//			LCD_StrDependOnColorsWindowIndirect(0,MIDDLE(0,LCD_X,win2.size.w) /* win2.pos.x */, win2.pos.y, win2.size.w, win2.size.h,fontID, GET_X(txt),GET_Y,txt, fullHight, 0, fillColor, DARKRED,250, NoConstWidth);
//			BKCOPY(fillColor,fillColor_c[0]);
//			vTimerService(1,start_time,2000);
//		}
//		void _WindowSpacesInfo(uint16_t x,uint16_t y, uint16_t width,uint16_t height, int param){
//			int spaceFromFrame = 10;
//			int heightUpDown = 17;
//			int widthtUpDown = 26;
//
//			int xPosU = MIDDLE(0,		width/2,widthtUpDown);
//			int xPosD = MIDDLE(width/2,width/2,widthtUpDown);
//			int yPosUD = height-heightUpDown-spaceFromFrame;
//
//			static uint16_t posTxt_temp=0;
//			static uint16_t posTxtTab[50]={0};
//			static uint16_t i_posTxtTab=0;
//
//			void 		_SetCurrPosTxt(uint16_t pos){ s[k].param2=pos; }
//			uint16_t _GetCurrPosTxt(void)			 { return s[k].param2; }
//
//			if(NoDirect==param){
//				touchTemp[0].x= win.pos.x + xPosU;
//				touchTemp[1].x= touchTemp[0].x + widthtUpDown;
//				touchTemp[0].y= win.pos.y + yPosUD;
//				touchTemp[1].y= touchTemp[0].y + heightUpDown;
//				LCD_TOUCH_Set(ID_TOUCH_POINT,Touch_SpacesInfoUp,press);
//				s[k].nmbTouch++;
//
//				touchTemp[0].x= win.pos.x + xPosD;
//				touchTemp[1].x= touchTemp[0].x + widthtUpDown;
//				touchTemp[0].y= win.pos.y + yPosUD;
//				touchTemp[1].y= touchTemp[0].y + heightUpDown;
//				LCD_TOUCH_Set(ID_TOUCH_POINT,Touch_SpacesInfoDown,press);
//				s[k].nmbTouch++;
//
//				_SetCurrPosTxt(0);
//				i_posTxtTab=0;
//			}
//			else if(Up==param){
//				CONDITION(1<i_posTxtTab && 0<posTxt_temp, i_posTxtTab-=2, i_posTxtTab--);
//				_SetCurrPosTxt(posTxtTab[i_posTxtTab]);
//			}
//
//			LCD_ShapeWindow( s[k].shape, 0, width,height, 0,0, width,height, SetBold2Color(frameColor,s[k].bold), bkColor,bkColor );
//			posTxt_temp = LCD_TxtWin(0,width,height,fontID_descr,spaceFromFrame,spaceFromFrame,LCD_DisplayRemeberedSpacesBetweenFonts(1,pCHAR_PLCD(width*height),NULL)+_GetCurrPosTxt(),fullHight,0,fillColor,v.FONT_COLOR_Descr,250,NoConstWidth).inChar;
//			if(posTxt_temp){
//				_SetCurrPosTxt(_GetCurrPosTxt()+posTxt_temp);
//				if(i_posTxtTab<sizeof(posTxtTab)-2)
//					posTxtTab[++i_posTxtTab]= _GetCurrPosTxt();
//			}
//
//			LCD_TOUCH_SusspendTouch(Touch_SpacesInfoUp);
//			LCD_TOUCH_SusspendTouch(Touch_SpacesInfoDown);
//
//			if(1 < i_posTxtTab || (1==i_posTxtTab && 0==posTxt_temp)){
//				LCDSHAPE_Window(LCDSHAPE_Arrow,0,LCD_Arrow(ToStructAndReturn,width,height, xPosU,yPosUD, SetLineBold2Width(widthtUpDown,7), SetTriangHeightCoeff2Height(heightUpDown,3), v.FONT_COLOR_Descr, v.FONT_COLOR_Descr, v.COLOR_BkScreen, Up));
//				LCD_TOUCH_RestoreSusspendedTouch(Touch_SpacesInfoUp);
//			}
//			if(0 < posTxt_temp){
//				LCD_Arrow(0,width,height, xPosD,yPosUD, SetLineBold2Width(widthtUpDown,7), SetTriangHeightCoeff2Height(heightUpDown-1,3), v.FONT_COLOR_Descr, v.FONT_COLOR_Descr, v.COLOR_BkScreen, Down);
//				LCD_TOUCH_RestoreSusspendedTouch(Touch_SpacesInfoDown);
//			}
//
//			LCD_Display(0, x,y, width,height);
//		}
//		int retVal=0;
//		void _CreateWindows(int nr,int param){
//			switch(nr){
//				case 0:
//					_WindowSpacesInfo(win.pos.x ,win.pos.y, win.size.w, win.size.h, param); _SetFlagWin();
//					break;
//				case 1:
//					break;
//			}
//		}
//		void _DeleteWindows(void){		/* Use function only after displaying (not during) */
//			pfunc(FUNC_MAIN_ARG);	_RstFlagWin();  LCD_DisplayPart(0,win.pos.x ,win.pos.y, win.size.w, win.size.h); retVal=1;
//			LCD_TOUCH_DeleteSelectTouch(Touch_SpacesInfoUp);
//			LCD_TOUCH_DeleteSelectTouch(Touch_SpacesInfoDown);
//			s[k].nmbTouch-=2;
//		}
//		void _OverArrowTxt(int nr, DIRECTIONS direct){
//			LCD_ArrowTxt(0,widthAll,heightAll, MIDDLE(posKey[nr].x, s[k].widthKey, widthShape1), MIDDLE(posKey[nr].y, s[k].heightKey, heightShape1), widthShape1,heightShape1, frameColor,frameColor,fillColor, direct,fontID,(char*)txtKey[nr],colorTxtKey[nr]);
//		}
//		void _OverArrowTxt_oneBlockDisp(int nr, DIRECTIONS direct){
//			LCD_ShapeWindow( s[k].shape, 0, s[k].widthKey,s[k].heightKey, 0,0, s[k].widthKey,s[k].heightKey, SetBold2Color(framePressColor,s[k].bold),fillPressColor,bkColor);
//			LCD_ArrowTxt(0,s[k].widthKey,s[k].heightKey, MIDDLE(0, s[k].widthKey, widthShape1), MIDDLE(0, s[k].heightKey, heightShape1), widthShape1,heightShape1, colorTxtPressKey[nr],colorTxtPressKey[nr],fillPressColor, direct,fontID,(char*)txtKey[nr],colorTxtPressKey[nr]);
//			LCD_Display(0, s[k].x+posKey[nr].x, s[k].y+posKey[nr].y, s[k].widthKey, s[k].heightKey);
//			if(_IsFlagWin())	_DeleteWindows();
//		}
//
//		switch((int)selBlockPress)
//		{
//			case KEY_All_release:
//				BKCOPY_VAL(frameColor_c[0],frameColor,WHITE);
//					LCD_ShapeWindow( s[k].shape,0,widthAll,heightAll, 0,0, widthAll,heightAll, SetBold2Color(frameColor,s[k].bold), bkColor,bkColor );		/* s[k].shape(0,widthAll,heightAll, 0,0, widthAll,heightAll, SetColorBoldFrame(frameColor,s[k].bold), bkColor,bkColor); */
//				BKCOPY(frameColor,frameColor_c[0]);
//			/*	posHead.y = s[k].interSpace/2; */											_StrDescr_Xmidd_Yoffs(posHead, 0, SL(LANG_LenOffsWin1), v.FONT_COLOR_Descr);		/* _StrDescr(k,posHead, SL(LANG_LenOffsWin), v.FONT_COLOR_Descr); */
//				posHead.y += LCD_GetFontHeight(fontID_descr)+s[k].interSpace/3;	_StrDescr_Xmidd_Yoffs(posHead, 0, SL(LANG_LenOffsWin2), v.FONT_COLOR_Descr);
//
//				BKCOPY_VAL(fillColor_c[0],fillColor,BrightIncr(fillColor,0xE));
//				for(int i=0; i<_NMB2KEY; ++i)
//				{
//					_Key(k,posKey[i]);
//					switch(i){
//						case 0: 	_OverArrowTxt(i,outside); 	  break;
//						case 1: 	_OverArrowTxt(i,inside); 	  break;
//						case 2: 	_OverArrowTxt(i,LeftLeft);   break;
//						case 3: 	_OverArrowTxt(i,RightRight); break;
//						case 4: 	_OverArrowTxt(i,LeftLeft);   break;
//						case 5: 	_OverArrowTxt(i,RightRight); break;
//						case 6: 	_OverArrowTxt(i,outside);	  break;
//						case 7: 	_OverArrowTxt(i,inside); 	  break;
//					}
//				}
//				BKCOPY(fillColor,fillColor_c[0]);
//
//				BKCOPY_VAL(fillColor_c[0],fillColor,BrightIncr(fillColor,0x6));
//				BKCOPY_VAL(c.widthKey,s[k].widthKey,s[k].widthKey2);
//				for(int i=_NMB2KEY; i<countKey; ++i)
//				{
//					if(i<countKey-1){
//						if(_IsFlagWin() && _NMB2KEY==i){		/* find key to hold press */
//							BKCOPY_VAL(fillColor_c[1],fillColor,fillPressColor);
//							BKCOPY_VAL(frameColor_c[0],frameColor,framePressColor);
//							 _KeyStr(k,posKey[i],txtKey[i],colorTxtPressKey[i]);
//							BKCOPY(fillColor,fillColor_c[1]);
//							BKCOPY(frameColor,frameColor_c[0]);
//						}
//						else _KeyStr(k,posKey[i],txtKey[i],colorTxtKey[i]);
//					}
//					else _KeyStrDisp(k,posKey[i],txtKey[i],colorTxtKey[i]);
//				}
//				BKCOPY(s[k].widthKey,c.widthKey);
//				BKCOPY(fillColor,fillColor_c[0]);
//				break;
//
//			case KEY_LenWin_plus: 		_OverArrowTxt_oneBlockDisp(0,outside);	 break;
//			case KEY_LenWin_minus: 		_OverArrowTxt_oneBlockDisp(1,inside);	 break;
//			case KEY_OffsWin_plus:  	_OverArrowTxt_oneBlockDisp(2,LeftLeft);	 break;
//			case KEY_OffsWin_minus: 	_OverArrowTxt_oneBlockDisp(3,RightRight);	 break;
//			case KEY_PosInWin_plus:    _OverArrowTxt_oneBlockDisp(4,LeftLeft);	 break;
//			case KEY_PosInWin_minus: 	_OverArrowTxt_oneBlockDisp(5,RightRight);	 break;
//			case KEY_SpaceFonts_plus:  _OverArrowTxt_oneBlockDisp(6,outside);	 break;
//			case KEY_SpaceFonts_minus: _OverArrowTxt_oneBlockDisp(7,inside);	 break;
//
//			case KEY_DispSpaces:	 BKCOPY_VAL(c.widthKey,s[k].widthKey,s[k].widthKey2);  _KeyStrPressDisp_oneBlock(k,posKey[8],txtKey[8],colorTxtPressKey[8]);		BKCOPY(s[k].widthKey,c.widthKey); CONDITION(_IsFlagWin(),_DeleteWindows(),_CreateWindows(0,NoDirect));  break;
//			case KEY_WriteSpaces: BKCOPY_VAL(c.widthKey,s[k].widthKey,s[k].widthKey2);  _KeyStrPressDisp_oneBlock(k,posKey[9],txtKey[9],colorTxtPressKey[9]);		BKCOPY(s[k].widthKey,c.widthKey); CONDITION(_IsFlagWin(),_DeleteWindows(),NULL);	 _WinInfo(SL(LANG_WinInfo));	 break;
//			case KEY_ResetSpaces: BKCOPY_VAL(c.widthKey,s[k].widthKey,s[k].widthKey2);  _KeyStrPressDisp_oneBlock(k,posKey[10],txtKey[10],colorTxtPressKey[10]);	BKCOPY(s[k].widthKey,c.widthKey); CONDITION(_IsFlagWin(),_DeleteWindows(),NULL);  _WinInfo(SL(LANG_WinInfo2));  break;
//
//			case KEY_InfoSpacesUp: 	 _CreateWindows(0,Up);    break;
//			case KEY_InfoSpacesDown: _CreateWindows(0,Down);  break;
//
//			case KEY_Timer: pfunc(FUNC_MAIN_ARG);  LCD_DisplayPart(0, MIDDLE(0,LCD_X,win2.size.w)/* win2.pos.x */, win2.pos.y, win2.size.w, win2.size.h);  break;
//		}
//
//		if(startTouchIdx){
//			for(int i=0; i<_NMB2KEY; ++i)
//				_SetTouch(k,ID_TOUCH_GET_ANY_POINT_WITH_WAIT, s[k].startTouchIdx + i, TOUCH_GET_PER_X_PROBE, posKey[i]);
//
//			BKCOPY_VAL(c.widthKey,s[k].widthKey,s[k].widthKey2);
//			 for(int i=_NMB2KEY; i<countKey; ++i)
//				 _SetTouch(k,ID_TOUCH_POINT, s[k].startTouchIdx + i, press, posKey[i]);
//			BKCOPY(s[k].widthKey,c.widthKey);
//		}
//		return retVal;
//		#undef _NMB2KEY
//	}

//	void _ServiceStyle(void)
//	{
//		const char *txtKey[]								= {"Arial", "Times_New_Roman", "Comic_Saens_MS"};
//		const COLORS_DEFINITION colorTxtKey[]		= {WHITE,	  WHITE, 	  			WHITE};
//		const COLORS_DEFINITION colorTxtPressKey[]= {DARKRED,	  DARKRED, 				DARKBLUE};
//		const uint16_t dimKeys[] = {1,3};
//
//		XY_Touch_Struct posKey[]=
//		  {{s[k].interSpace, 1*s[k].interSpace + 0*s[k].heightKey - 0},
//			{s[k].interSpace, 2*s[k].interSpace + 1*s[k].heightKey - 1},
//			{s[k].interSpace, 3*s[k].interSpace + 2*s[k].heightKey - 2}};
//
//		int countKey = STRUCT_TAB_SIZE(txtKey);
//		framePressColor = frameColor;
//		widthAll  = dimKeys[0]*s[k].widthKey  + (dimKeys[0]+1)*s[k].interSpace;
//		heightAll = dimKeys[1]*s[k].heightKey + (dimKeys[1]+1)*s[k].interSpace - (countKey-1);
//
//		switch((int)selBlockPress)
//		{
//			case KEY_Select_one:
//				LCD_ShapeWindow( s[k].shape,0,widthAll,heightAll, 0,0, widthAll,heightAll, SetBold2Color(frameColor,s[k].bold), bkColor,bkColor );
//
//				fillColor = 0xFF111111;
//
//				for(int i=0; i<countKey; ++i)
//				{
//					if((i==0 && Test.style==Arial) ||
//						(i==1 && Test.style==Times_New_Roman) ||
//						(i==2 && Test.style==Comic_Saens_MS))
//					{
//							i<countKey-1 ? _KeyStrPress(k,posKey[i],txtKey[i],colorTxtPressKey[i]) : _KeyStrPressDisp(k,posKey[i],txtKey[i],colorTxtPressKey[i]);
//						/* _KeyPress(posKey[i]); _TxtPos(posKey[i]);    i<countKey-1 ? _StrPress(txtKey[i],colorTxtPressKey[i]) : _StrPressDisp(txtKey[i],colorTxtPressKey[i]); */		/* This is the same as up */
//					}
//					else{	i<countKey-1 ? _KeyStr(k,posKey[i],txtKey[i],colorTxtKey[i]) : _KeyStrDisp(k,posKey[i],txtKey[i],colorTxtKey[i]);
//						/* _Key(posKey[i]); _TxtPos(posKey[i]);   i<countKey-1 ? _Str(txtKey[i],colorTxtKey[i]) : _StrDisp(txtKey[i],colorTxtKey[i]); */		/* This is the same as up */
//					}
//				}
//				break;
//		}
//
//		if(startTouchIdx){
//			for(int i=0; i<countKey; ++i)
//				_SetTouch(k,ID_TOUCH_POINT, s[k].startTouchIdx + i, press, posKey[i]);
//		}
//	}
//
//	void _ServiceType(void)
//	{
//		const char *txtKey[]								= {"(Gray-Green)", "(Gray-White)", "(White-Black)"};
//		const COLORS_DEFINITION colorTxtKey[]		= {WHITE,	  		 WHITE, 	  			WHITE};
//		const COLORS_DEFINITION colorTxtPressKey[]= {BLACK,	  		 BROWN, 				ORANGE};
//		const uint16_t dimKeys[] = {1,3};
//
//		XY_Touch_Struct posKey[]=
//		  {{s[k].interSpace, 1*s[k].interSpace + 0*s[k].heightKey - 0},
//			{s[k].interSpace, 2*s[k].interSpace + 1*s[k].heightKey - 1},
//			{s[k].interSpace, 3*s[k].interSpace + 2*s[k].heightKey - 2}};
//
//		int countKey = STRUCT_TAB_SIZE(txtKey);
//
//		framePressColor = frameColor;
//		widthAll  = dimKeys[0]*s[k].widthKey  + (dimKeys[0]+1)*s[k].interSpace;
//		heightAll = dimKeys[1]*s[k].heightKey + (dimKeys[1]+1)*s[k].interSpace - (countKey-1);
//
//		switch((int)selBlockPress)
//		{
//			case KEY_Select_one:
//				LCD_ShapeWindow( s[k].shape,0,widthAll,heightAll, 0,0, widthAll,heightAll, SetBold2Color(frameColor,s[k].bold), bkColor,bkColor );
//
//				for(int i=0; i<countKey; ++i)
//				{
//					if((i==0 && Test.type==0) ||
//						(i==1 && Test.type==1) ||
//						(i==2 && Test.type==2))
//					{
//							i<countKey-1 ? _KeyStrPress(k,posKey[i],txtKey[i],colorTxtPressKey[i]) : _KeyStrPressDisp(k,posKey[i],txtKey[i],colorTxtPressKey[i]);
//					}
//					else{	i<countKey-1 ? _KeyStr(k,posKey[i],txtKey[i],colorTxtKey[i]) : _KeyStrDisp(k,posKey[i],txtKey[i],colorTxtKey[i]);
//					}
//				}
//				break;
//		}
//
//		if(startTouchIdx){
//			for(int i=0; i<countKey; ++i)
//				_SetTouch(k,ID_TOUCH_POINT, s[k].startTouchIdx + i, press, posKey[i]);
//		}
//	}
//
//	void _ServiceSize(void)
//	{
//		const char *txtKey[]								= {"Size +",	"Size -"};
//		const COLORS_DEFINITION colorTxtKey[]		= {WHITE,	  	WHITE};
//		const COLORS_DEFINITION colorTxtPressKey[]= {DARKRED,		BLACK};
//		const uint16_t dimKeys[] = {1,2};
//
//		XY_Touch_Struct posHead={0,0};
//		int head = s[k].interSpace + LCD_GetFontHeight(fontID_descr) + s[k].interSpace;
//
//		XY_Touch_Struct posKey[]=
//		  {{1*s[k].interSpace + 0*s[k].widthKey,	1*s[k].interSpace + 0*s[k].heightKey + head},
//			{1*s[k].interSpace + 0*s[k].widthKey,	2*s[k].interSpace + 1*s[k].heightKey + head}};
//
//		const char *txtKey2[]								= {"Normal", "Bold", "Italic"};
//		const COLORS_DEFINITION colorTxtKey2[]			= {WHITE,	  WHITE,  WHITE};
//		const COLORS_DEFINITION colorTxtPressKey2[]	= {BLACK,	  BROWN,  ORANGE};
//		const uint16_t dimKeys2[] = {1,3};
//		int ofs=s[k].interSpace + s[k].widthKey;
//		XY_Touch_Struct posKey2[]=
//		  {{s[k].interSpace+ofs, 1*s[k].interSpace + 0*s[k].heightKey - 0 + head},
//			{s[k].interSpace+ofs, 1*s[k].interSpace + 1*s[k].heightKey - 1 + head},
//			{s[k].interSpace+ofs, 1*s[k].interSpace + 2*s[k].heightKey - 2 + head}};
//
//		int countKey = dimKeys[0]*dimKeys[1];
//		int countKey2 = dimKeys2[0]*dimKeys2[1];
//
//		widthAll =  (s[k].interSpace + s[k].widthKey + s[k].interSpace) + (s[k].widthKey + s[k].interSpace);
//		heightAll = s[k].interSpace + dimKeys2[1]*s[k].heightKey + s[k].interSpace - (countKey2-1) + head;
//
//		switch((int)selBlockPress)
//		{
//			case KEY_All_release_and_select_one:
//				LCD_ShapeWindow( s[k].shape,0,widthAll,heightAll, 0,0, widthAll,heightAll, SetBold2Color(frameColor,s[k].bold), bkColor,bkColor );
//				_StrDescr(k,posHead, SL(LANG_nazwa_0), v.FONT_COLOR_Descr);
//
//				for(int i=0; i<countKey; ++i)
//					_KeyStr(k,posKey[i],txtKey[i],colorTxtKey[i]);
//
//				c.shape = s[k].shape;	s[k].shape = LCD_Rectangle;
//				framePressColor = frameColor;
//
//				for(int i=0; i<countKey2; ++i)
//				{
//					if((i==0 && Test.normBoldItal==0) ||
//						(i==1 && Test.normBoldItal==1) ||
//						(i==2 && Test.normBoldItal==2))
//					{
//							i<countKey2-1 ? _KeyStrPress(k,posKey2[i],txtKey2[i],colorTxtPressKey2[i]) : _KeyStrPressDisp(k,posKey2[i],txtKey2[i],colorTxtPressKey2[i]);
//					}
//					else{	i<countKey2-1 ? _KeyStr(k,posKey2[i],txtKey2[i],colorTxtKey2[i]) : _KeyStrDisp(k,posKey2[i],txtKey2[i],colorTxtKey2[i]);
//					}
//				}
//				s[k].shape = c.shape;
//				break;
//
//			case KEY_Size_plus:	 _KeyStrPressDisp_oneBlock(k,posKey[0], txtKey[0], colorTxtPressKey[0]);	break;
//			case KEY_Size_minus:	 _KeyStrPressDisp_oneBlock(k,posKey[1], txtKey[1], colorTxtPressKey[1]);	break;
//		}
//
//		if(startTouchIdx){
//			int touch_it=0;  // touch_it and  s[k].nmbTouch is the same  !!!!
//			for(int i=0; i<countKey; ++i)
//				_SetTouch(k,ID_TOUCH_GET_ANY_POINT_WITH_WAIT, s[k].startTouchIdx + touch_it++, TOUCH_GET_PER_X_PROBE, posKey[i]);
//
//			for(int i=0; i<countKey2; ++i)
//				_SetTouch(k,ID_TOUCH_POINT, s[k].startTouchIdx + touch_it++, press, posKey2[i]);
//		}
//	}
//
//	void _ServiceSizeRoll(void)
//	{
//		#define _FRAME2ROLL
//
//		const uint16_t dimKeys[] = {1,LCD_GetFontSizeMaxNmb()};
//		const char *txtKey[dimKeys[1]];
//		COLORS_DEFINITION colorTxtKey[dimKeys[1]];
//		COLORS_DEFINITION colorTxtPressKey = DARKRED;
//		XY_Touch_Struct posKey[dimKeys[1]];
//
//		#ifdef _FRAME2ROLL
//			XY_Touch_Struct posHead = {0,5};
//			uint16_t spaceFrame2Roll = 10;
//			int head = posHead.y + LCD_GetFontHeight(fontID_descr) + posHead.y;
//		#endif
//
//		if(shape!=0){
//			if(KeysAutoSize == widthKey){
//				s[k].widthKey =  heightKey + LCD_GetWholeStrPxlWidth(fontID,(char*)LCD_GetFontSizeStr(50),0,NoConstWidth) + heightKey;		/*	space + text + space */
//				s[k].heightKey = heightKey + LCD_GetFontHeight(fontID) + heightKey;
//			}
//		}
//
//		int frameNmbVis = 8;
//		uint16_t roll = 0, roll_copy = 0;
//		uint16_t selFrame = Test.size;
//
//		int countKey = dimKeys[1];
//		int win = frameNmbVis * s[k].heightKey - (frameNmbVis-1);
//		int fillColor_copy = fillColor;
//
//		if(shape!=0){
//			if(dimKeys[1]-selFrame <= frameNmbVis/2)	roll = dimKeys[1]-frameNmbVis-1;
//			else if(		  selFrame <= frameNmbVis/2)	roll = 0;
//			else													roll = selFrame - frameNmbVis/2;
//
//			roll_copy = roll;
//			roll *= s[k].heightKey;
//			roll -= roll_copy;
//			LCD_TOUCH_ScrollSel_SetCalculate(ROLL_1, &roll, &selFrame, 0,0,0,countKey/frameNmbVis);
//		}
//
//		for(int i=0; i<countKey; ++i)
//		{
//			txtKey[i] = LCD_GetFontSizeStr(i);
//			colorTxtKey[i] = COLOR_GRAY(0xDD);
//
//			posKey[i].x = s[k].interSpace;
//			posKey[i].y = (i+1)*s[k].interSpace + i*s[k].heightKey - i;
//		}
//
//		framePressColor = frameColor;
//		widthAll  = dimKeys[0]*s[k].widthKey  + (dimKeys[0]+1)*s[k].interSpace;
//		heightAll = dimKeys[1]*s[k].heightKey + (dimKeys[1]+1)*s[k].interSpace - (countKey-1);
//
//		switch((int)selBlockPress)
//		{
//			case KEY_Select_one:
//				if(shape!=0)
//				{
//					#ifdef _FRAME2ROLL
//						BKCOPY_VAL(heightAll_c,heightAll,head+win+spaceFrame2Roll);
//						BKCOPY_VAL(widthAll_c,widthAll,widthAll+2*spaceFrame2Roll);
//
//						  LCD_ShapeWindow( LCD_RoundRectangle,0,widthAll,heightAll, 0,0, widthAll,heightAll, SetBold2Color(frameColor,s[k].bold), bkColor,bkColor );
//
//						  BKCOPY_VAL(c.interSpace,s[k].interSpace,posHead.y);
//					 		 _StrDescr(k,posHead, SL(LANG_nazwa_0), v.FONT_COLOR_Descr);
//					 	  BKCOPY(s[k].interSpace,c.interSpace);
//
//					 	  LCD_Display(0, s[k].x-spaceFrame2Roll, s[k].y-head, widthAll, heightAll);
//
//					 	BKCOPY(widthAll,widthAll_c);
//					 	BKCOPY(heightAll,heightAll_c);
//					#else
//					 	LCD_ShapeWindow( LCD_RoundRectangle,0,widthAll,heightAll, 0,0, widthAll,heightAll, SetBold2Color(frameColor,s[k].bold), bkColor,bkColor );
//					#endif
//
//				}
//
//				if(shape==0)
//					LCD_TOUCH_ScrollSel_SetCalculate(ROLL_1, &roll, &selFrame, s[k].y, heightAll, s[k].heightKey, win);
//
//				for(int i=0; i<countKey; ++i)
//				{
//					if(i == selFrame)
//						_KeyStrPressLeft(k,posKey[i],txtKey[i],colorTxtPressKey);		/* _KeyStrPress(posKey[i],txtKey[i],colorTxtPressKey); */
//					else{
//						fillColor = (i%2) ? BrightDecr(fillColor_copy,0x20) : fillColor_copy;
//						_KeyStrleft(k,posKey[i],txtKey[i],colorTxtKey[i]);				/*	_KeyStr(posKey[i],txtKey[i],colorTxtKey[i]); */
//					}
//				}
//				LCD_Display(0 + roll * widthAll, s[k].x, s[k].y, widthAll, win);
//				break;
//		}
//
//		if(startTouchIdx){
//			touchTemp[0].x= s[k].x + posKey[0].x;
//			touchTemp[1].x= touchTemp[0].x + s[k].widthKey;
//			touchTemp[0].y= s[k].y + posKey[0].y;
//			touchTemp[1].y= touchTemp[0].y + win;
//			LCD_TOUCH_Set(ID_TOUCH_GET_ANY_POINT, s[k].startTouchIdx, TOUCH_GET_PER_ANY_PROBE);
//			s[k].nmbTouch++;
//		}
//	}


//	void _ServiceSliderRGB(void)
//	{
//		const char *txtSliders[]							= {"Red","Green","Blue"};
//		const COLORS_DEFINITION colorTxtSliders[]		= {RED, GREEN, BLUE};
//		const uint16_t dimSlider[] = {1,3};
//
//		uint32_t LineColor 	= frameColor;
//		uint32_t LineSelColor = COLOR_GRAY(0x77);
//		uint32_t spaceTriangLine = 11;	/* DelTriang */
//		int maxSliderValue = 255;
//		int *pValForSlider = (int*)(&Test.font[0]);
//		VOID_FUNCTION *funcForSlider = RefreshValRGB;
//
//		int head = s[k].interSpace + LCD_GetFontHeight(fontID_descr) + s[k].interSpace;
//		XY_Touch_Struct posHead={0,0};
//		XY_Touch_Struct posSlider[]=
//		  {{1*s[k].interSpace,	1*s[k].interSpace + 0*s[k].heightKey + head},
//			{1*s[k].interSpace,	2*s[k].interSpace + 1*s[k].heightKey + head},
//			{1*s[k].interSpace, 	3*s[k].interSpace + 2*s[k].heightKey + head}};
//
//		int countKey = STRUCT_TAB_SIZE(txtSliders);
//		SHAPE_PARAMS elemSliderPos[countKey];
//
//		widthAll =  dimSlider[0]*s[k].widthKey  + (dimSlider[0]+1)*s[k].interSpace;
//		heightAll = dimSlider[1]*s[k].heightKey + (dimSlider[1]+1)*s[k].interSpace + head;
//
//		switch((int)selBlockPress)
//		{
//			case KEY_All_release:
//				LCD_ShapeWindow( s[k].shape,0,widthAll,heightAll, 0,0, widthAll,heightAll, SetBold2Color(frameColor,s[k].bold), bkColor,bkColor );
//				_StrDescr(k,posHead, SL(LANG_nazwa_1), v.FONT_COLOR_Descr);
//
//				for(int i=0; i<countKey; ++i){
//					elemSliderPos[i] = LCD_SimpleSlider(0, widthAll,heightAll, posSlider[i].x, posSlider[i].y, ChangeElemSliderSize(s[k].widthKey,NORMAL_SLIDER_PARAM), SetSpaceTriangLineSlider(s[k].heightKey,spaceTriangLine), LineColor, LineSelColor ,colorTxtSliders[i], bkColor, SetValType(PERCENT_SCALE(*(pValForSlider+i)+1,maxSliderValue+1),Percent), NoSel);
//					_StrDescr_Xmidd_Yoffs(posSlider[i],- LCD_GetFontHeight(fontID_descr), txtSliders[i], colorTxtSliders[i]);
//				}
//				LCD_Display(0, s[k].x, s[k].y, widthAll, heightAll);
//				break;
//
//			case KEY_Red_slider:		_ElemSliderPressDisp_oneBlock(k,x,posSlider[0],spaceTriangLine, ChangeElemSliderColor(PtrSel,  colorTxtSliders[0]),LineColor,LineSelColor,pValForSlider+0, PosX,maxSliderValue,funcForSlider);	 break;
//			case KEY_Green_slider:	_ElemSliderPressDisp_oneBlock(k,x,posSlider[1],spaceTriangLine, ChangeElemSliderColor(PtrSel,  colorTxtSliders[1]),LineColor,LineSelColor,pValForSlider+1, PosX,maxSliderValue,funcForSlider);	 break;
//			case KEY_Blue_slider:	_ElemSliderPressDisp_oneBlock(k,x,posSlider[2],spaceTriangLine, ChangeElemSliderColor(PtrSel,  colorTxtSliders[2]),LineColor,LineSelColor,pValForSlider+2, PosX,maxSliderValue,funcForSlider);	 break;
//			case KEY_Red_minus:		_ElemSliderPressDisp_oneBlock(k,x,posSlider[0],spaceTriangLine, ChangeElemSliderColor(LeftSel, colorTxtSliders[0]),LineColor,LineSelColor,pValForSlider+0, Percent,maxSliderValue,funcForSlider);	 break;
//			case KEY_Red_plus:		_ElemSliderPressDisp_oneBlock(k,x,posSlider[0],spaceTriangLine, ChangeElemSliderColor(RightSel,colorTxtSliders[0]),LineColor,LineSelColor,pValForSlider+0, Percent,maxSliderValue,funcForSlider);	 break;
//			case KEY_Green_minus:	_ElemSliderPressDisp_oneBlock(k,x,posSlider[1],spaceTriangLine, ChangeElemSliderColor(LeftSel, colorTxtSliders[1]),LineColor,LineSelColor,pValForSlider+1, Percent,maxSliderValue,funcForSlider);	 break;
//			case KEY_Green_plus:		_ElemSliderPressDisp_oneBlock(k,x,posSlider[1],spaceTriangLine, ChangeElemSliderColor(RightSel,colorTxtSliders[1]),LineColor,LineSelColor,pValForSlider+1, Percent,maxSliderValue,funcForSlider);	 break;
//			case KEY_Blue_minus:		_ElemSliderPressDisp_oneBlock(k,x,posSlider[2],spaceTriangLine, ChangeElemSliderColor(LeftSel, colorTxtSliders[2]),LineColor,LineSelColor,pValForSlider+2, Percent,maxSliderValue,funcForSlider);	 break;
//			case KEY_Blue_plus:		_ElemSliderPressDisp_oneBlock(k,x,posSlider[2],spaceTriangLine, ChangeElemSliderColor(RightSel,colorTxtSliders[2]),LineColor,LineSelColor,pValForSlider+2, Percent,maxSliderValue,funcForSlider);	 break;
//		}
//
//		if(startTouchIdx){
//			for(int i=0; i<countKey; ++i)
//				_SetTouchSlider(k,s[k].startTouchIdx, elemSliderPos[i]); //po co 'k' i 's[k].startTouchIdx'  ????!!
//		}
//	}

//
//	void _ServiceSetTxt(void) // klawiatura malutka i duza na caly LCD_X z liczbami
//	{
//		#define _UP		"|"
//		#define _LF		"<--"
//		#define _EN		"<-|"
//		#define _EX		"X"
//
//		const char *txtKey[]								= {"q","w","e","r","t","y","u","i","o","p", \
//																	  "a","s","d","f","g","h","j","k","l", \
//																	_UP,"z","x","c","v","b","n","m",_LF, \
//																	"alt",_EX,"space",",",".",_EN };  //Sign 'S' to klawiatyra liczbnowa dla malej klawiatury
//
////		const char *txtKey2[]							= {"/","1","2","3", \
////																	"*","4","5","6", \
////																	"-","7","8","9", \
////																	"+","=",".","0" };
//
//		const COLORS_DEFINITION colorTxtKey[]		= {WHITE,WHITE,WHITE,WHITE,WHITE,WHITE,WHITE,WHITE,WHITE,WHITE, \
//																	WHITE,WHITE,WHITE,WHITE,WHITE,WHITE,WHITE,WHITE,WHITE, \
//																	WHITE,WHITE,WHITE,WHITE,WHITE,WHITE,WHITE,WHITE,WHITE, \
//																	WHITE,WHITE,WHITE,WHITE,WHITE,WHITE };
//
//		const COLORS_DEFINITION colorTxtPressKey[]= {DARKRED,DARKRED,DARKRED,DARKRED,DARKRED,DARKRED,DARKRED,DARKRED,DARKRED,DARKRED, \
//																	DARKRED,DARKRED,DARKRED,DARKRED,DARKRED,DARKRED,DARKRED,DARKRED,DARKRED, \
//																	DARKRED,DARKRED,DARKRED,DARKRED,DARKRED,DARKRED,DARKRED,DARKRED,DARKRED, \
//																	DARKRED,DARKRED,DARKRED,DARKRED,DARKRED,DARKRED };
//
//		const uint8_t dimKeys[] = {10,9,9,6};
//
//		#define _PARAM_ARROW_UP		structSize 	size_UP = { (35*s[k].widthKey)/100,  (2*s[k].heightKey)/5 };		int bold_UP = 1;		int coeff_UP = 3
//		#define _PARAM_ARROW_LF		structSize 	size_LF = { ( 2*s[k].widthKey)/4,    (2*s[k].heightKey)/7 };		int bold_LF = 1;		int coeff_LF = 0
//		#define _PARAM_ARROW_EN		structSize 	size_EN = { ( 2*s[k].widthKey)/4,    (2*s[k].heightKey)/7 };		int bold_EN = 1;		int coeff_EN = 0
//		#define _PARAM_ARROW_EX		structSize 	size_EX = { (35*s[k].heightKey)/100, (35*s[k].heightKey)/100 };
//
//		if(shape!=0){
//			if(KeysAutoSize == widthKey){
//				s[k].widthKey =  heightKey + LCD_GetWholeStrPxlWidth(fontID,(char*)txtKey[0],0,NoConstWidth) + heightKey;
//				s[k].heightKey = heightKey + LCD_GetFontHeight(fontID) + heightKey;
//		}}
//
//		int widthFieldTxt = 0;
//		int heightFieldTxt = LCD_GetFontHeight(fontID) * 3;
//		int head = s[k].interSpace + heightFieldTxt + s[k].interSpace;
//
//		#define W1	s[k].widthKey
//		#define WS	4*W1 + 3*s[k].interSpace
//		#define WA	W1 + (W1 + s[k].interSpace)/2
//
//		uint16_t widthKey[]= {W1,W1,W1,W1,W1,W1,W1,W1,W1,W1,\
//									W1,W1,W1,W1,W1,W1,W1,W1,W1,\
//									WA,W1,W1,W1,W1,W1,W1,W1,WA,\
//									WA,W1,WS,W1,W1,WA};
//
//		INIT(nr,0);		INIT(width_c,0);
//		#define P(x,y,offs)	{(x+1)*s[k].interSpace + offs + CONDITION(0==x, width_c=_ReturnVal(0,CONDITION(0==y,nr=0,nr++)), width_c += widthKey[nr++]),		(y+1)*s[k].interSpace + y*s[k].heightKey + head}
//		#define F	(s[k].widthKey+s[k].interSpace)/2
//
//		XY_Touch_Struct posKey[]= {P(0,0,0),P(1,0,0),P(2,0,0),P(3,0,0),P(4,0,0),P(5,0,0),P(6,0,0),P(7,0,0),P(8,0,0),P(9,0,0),\
//											P(0,1,F),P(1,1,F),P(2,1,F),P(3,1,F),P(4,1,F),P(5,1,F),P(6,1,F),P(7,1,F),P(8,1,F),\
//											P(0,2,0),P(1,2,0),P(2,2,0),P(3,2,0),P(4,2,0),P(5,2,0),P(6,2,0),P(7,2,0),P(8,2,0),\
//											P(0,3,0),P(1,3,0),P(2,3,0),P(3,3,0),P(4,3,0),P(5,3,0)};
//
//		INIT_INCVAL(sizeof(dimKeys),countKey,dimKeys);
//		INIT_MAXVAL(dimKeys,sizeof(dimKeys),0,maxVal);
//
//		widthAll =  maxVal*s[k].widthKey  + (maxVal+1)*s[k].interSpace;
//		heightAll = sizeof(dimKeys)*s[k].heightKey + (sizeof(dimKeys)+1)*s[k].interSpace + head;
//		widthFieldTxt = widthAll - 2*s[k].interSpace;
//
//		void _KeyQ2P(int nr, int act){
//			if(release==act)	_Key(k,posKey[nr]);
//			else	 				_KeyPressWin(k);
//
//			char *ptrTxt = Int2Str(nr,None,1,Sign_none);
//			int widthDescr = LCD_GetWholeStrPxlWidth(fontID_descr,ptrTxt,0,ConstWidth);
//			int heightTxt = LCD_GetFontHeight(fontID);
//
//			if(release==act){	 _StrDescr_XYoffs(posKey[nr], s[k].widthKey-VALPERC(widthDescr,180), VALPERC(widthDescr,35), ptrTxt, 		BrightIncr(v.FONT_COLOR_Descr,0x20));
//									 _Str_Xmidd_Yoffs(k,posKey[nr], s[k].heightKey-VALPERC(heightTxt,115), 								txtKey[nr],  colorTxtKey[nr]);
//			}
//			else{			BKCOPY_VAL(fillColor_c[0],fillColor,fillPressColor);
//									_StrDescrWin_XYoffs(k,s[k].widthKey-VALPERC(widthDescr,180), VALPERC(widthDescr,35), ptrTxt, 	  BrightIncr(v.FONT_COLOR_Descr,0x20));
//									_StrWin_Xmidd_Yoffs(k,s[k].heightKey-VALPERC(heightTxt,115), 								  txtKey[nr], colorTxtPressKey[nr]);
//							BKCOPY(fillColor,fillColor_c[0]);
//			}
//			if(press==act) LCD_Display(0,s[k].x+posKey[nr].x,s[k].y+posKey[nr].y,s[k].widthKey,s[k].heightKey);
//		}
//
//		int colorFillBk = BrightDecr(bkColor,0x10);
//		switch((int)selBlockPress)
//		{
//			case KEY_All_release:
//				LCD_ShapeWindow( s[k].shape,0,widthAll,heightAll, 0,0, widthAll,heightAll, SetBold2Color(frameColor,s[k].bold), colorFillBk,bkColor );
//				LCD_ShapeWindow( s[k].shape,0,widthAll,heightAll, s[k].interSpace,s[k].interSpace, widthFieldTxt,heightFieldTxt, SetBold2Color(BrightDecr(frameColor,0x40),s[k].bold), BrightDecr(frameColor,0x40),colorFillBk );
//
//				fillColor = BrightIncr(fillColor,0x10);
//				bkColor = colorFillBk;
//
//				c.widthKey = s[k].widthKey;
//				for(int i=0; i<countKey; ++i)
//				{
//					s[k].widthKey = widthKey[i];
//					if(STRING_CmpTxt((char*)txtKey[i],_UP)){	 		_Key(k,posKey[i]);	_PARAM_ARROW_UP;
//						LCD_Arrow(0,widthAll,heightAll, MIDDLE(posKey[i].x,s[k].widthKey,size_UP.w),MIDDLE(posKey[i].y,s[k].heightKey,size_UP.h), SetLineBold2Width(size_UP.w,bold_UP), SetTriangHeightCoeff2Height(size_UP.h,coeff_UP), frameColor,frameColor,bkColor, Up);
//					}
//					else if(STRING_CmpTxt((char*)txtKey[i],_LF)){	_Key(k,posKey[i]);	_PARAM_ARROW_LF;
//						LCD_Arrow(0,widthAll,heightAll, MIDDLE(posKey[i].x,s[k].widthKey,size_LF.w),MIDDLE(posKey[i].y,s[k].heightKey,size_LF.h), SetLineBold2Width(size_LF.w,bold_LF), SetTriangHeightCoeff2Height(size_LF.h,coeff_LF), frameColor,frameColor,bkColor, Left);
//					}
//					else if(STRING_CmpTxt((char*)txtKey[i],_EN)){	_Key(k,posKey[i]);	_PARAM_ARROW_EN;
//						LCD_Enter(0,widthAll,heightAll, MIDDLE(posKey[i].x,s[k].widthKey,size_EN.w),MIDDLE(posKey[i].y,s[k].heightKey,size_EN.h), SetLineBold2Width(size_EN.w,bold_EN), SetTriangHeightCoeff2Height(size_EN.h,coeff_EN), frameColor,frameColor,bkColor);
//						LCD_Display(0, s[k].x, s[k].y, widthAll, heightAll);
//					}
//					else if(STRING_CmpTxt((char*)txtKey[i],_EX)){	_KeyPress(k,posKey[i]);	_PARAM_ARROW_EX;
//						LCD_Exit(0,widthAll,heightAll, MIDDLE(posKey[i].x,s[k].widthKey,size_EX.w),MIDDLE(posKey[i].y,s[k].heightKey,size_EX.h), size_EX.w, size_EX.h, colorTxtPressKey[i],colorTxtPressKey[i],bkColor);
//					}
//					else{
//						if(i<dimKeys[0]) _KeyQ2P(i,release);
//						else 				  _KeyStr(k,posKey[i],txtKey[i],colorTxtKey[i]);
//					}
//				}
//				s[k].widthKey = c.widthKey;
//				break;
//
//			case KEY_big:
//				nr = selBlockPress-KEY_Q;
//				BKCOPY_VAL(c.widthKey,s[k].widthKey,widthKey[nr]);		_PARAM_ARROW_UP;
//				_KeyShapePressDisp_oneBlock(k,posKey[nr], LCDSHAPE_Arrow, LCD_Arrow(ToStructAndReturn,s[k].widthKey,s[k].heightKey, MIDDLE(0,s[k].widthKey,size_UP.w),MIDDLE(0,s[k].heightKey,size_UP.h), SetLineBold2Width(size_UP.w,bold_UP), SetTriangHeightCoeff2Height(size_UP.h,coeff_UP), colorTxtPressKey[nr],colorTxtPressKey[nr],bkColor, Up));
//				BKCOPY(s[k].widthKey,c.widthKey);
//				break;
//
//			case KEY_back:
//				nr = selBlockPress-KEY_Q;
//				BKCOPY_VAL(c.widthKey,s[k].widthKey,widthKey[nr]);		_PARAM_ARROW_LF;
//				_KeyShapePressDisp_oneBlock(k,posKey[nr], LCDSHAPE_Arrow, LCD_Arrow(ToStructAndReturn,s[k].widthKey,s[k].heightKey, MIDDLE(0,s[k].widthKey,size_LF.w),MIDDLE(0,s[k].heightKey,size_LF.h), SetLineBold2Width(size_LF.w,bold_LF), SetTriangHeightCoeff2Height(size_LF.h,coeff_LF), colorTxtPressKey[nr],colorTxtPressKey[nr],bkColor, Left));
//				BKCOPY(s[k].widthKey,c.widthKey);
//				break;
//
//			case KEY_enter:
//				nr = selBlockPress-KEY_Q;
//				BKCOPY_VAL(c.widthKey,s[k].widthKey,widthKey[nr]);		_PARAM_ARROW_EN;
//				_KeyShapePressDisp_oneBlock(k,posKey[nr], LCDSHAPE_Enter, LCD_Enter(ToStructAndReturn,s[k].widthKey,s[k].heightKey, MIDDLE(0,s[k].widthKey,size_EN.w),MIDDLE(0,s[k].heightKey,size_EN.h), SetLineBold2Width(size_EN.w,bold_EN), SetTriangHeightCoeff2Height(size_EN.h,coeff_EN), colorTxtPressKey[nr],colorTxtPressKey[nr],bkColor));
//				BKCOPY(s[k].widthKey,c.widthKey);
//				break;
//
//			default:
//					  if(IS_RANGE(selBlockPress,KEY_Q,KEY_P)){	   INIT(nr,selBlockPress-KEY_Q); BKCOPY_VAL(c.widthKey,s[k].widthKey,widthKey[nr]);   _KeyQ2P(nr,press);  																		BKCOPY(s[k].widthKey,c.widthKey); }
//				else if(IS_RANGE(selBlockPress,KEY_A,KEY_enter)){ 	INIT(nr,selBlockPress-KEY_Q); BKCOPY_VAL(c.widthKey,s[k].widthKey,widthKey[nr]);   _KeyStrPressDisp_oneBlock(k,posKey[nr],txtKey[nr],colorTxtPressKey[nr]); 	BKCOPY(s[k].widthKey,c.widthKey); }
//				break;
//		}
//
//		if(startTouchIdx){
//			for(int i=0; i<countKey; ++i){
//				BKCOPY_VAL(c.widthKey,s[k].widthKey,widthKey[i]);
//				_SetTouch(k,ID_TOUCH_POINT,s[k].startTouchIdx+i,press,posKey[i]);
//				BKCOPY(s[k].widthKey,c.widthKey);
//		}}
//		#undef P
//		#undef F
//		#undef W1
//		#undef WS
//		#undef WA
//		#undef _UP
//		#undef _LF
//		#undef _EN
//		#undef _EX
//	}
//


LCD_SimpleSliderH(0, LCD_X,LCD_Y, 50,220, ChangeElemSliderSize(200,NORMAL_SLIDER_PARAM), SetSpaceTriangLineSlider(54,10), WHITE, GRAY , RED, v.COLOR_BkScreen, SetValType(80,Percent), ChangeElemSliderColor(LeftSel, BLUE));

LCD_SimpleSliderV(0, LCD_X,LCD_Y, 650,220, ChangeElemSliderSize(200,NORMAL_SLIDER_PARAM), SetSpaceTriangLineSlider(54,10), WHITE, GRAY , RED, v.COLOR_BkScreen, SetValType(25,Percent), ChangeElemSliderColor(LeftSel, BLUE));




